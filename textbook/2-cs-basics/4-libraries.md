# Функции, библиотеки и компоновщик

## ПППНП (Первое правило программирования: "не повторяйся")

<!-- TODO: Добавить мемасик в стиле XKCD про идиотизм всяких аббревиатур:
DRY, MEAN, SCRUM, ASD, TS, CSS, HTML, SASS, DB, ORM, SQL, AWS, CI/CD, -->

Расскажу одну историю. Наши программисты писали защищённый мессенджер.
В разных местах программы необходимо было расшифровывать и зашифровывать данные.
Например, прежде чем сохранить данные на диск, надо было их зашифровать. Прежде
чем отправить их по сети - тоже. А алгоритмы шифрования ой какие сложные: они
занимают много инструкций, и если ты допустишь в алгоритме хоть одну ошибку, то он
станет, в лучшем случае, абсолютно бесполезным, а в худшем - опасным.

Но мы смирились. И во многих местах нашей программы повторялся один и тот же алгоритм
шифрования. Одна и та же последовательность инструкций, дублирующаяся через всю нашу программу
и потому занимающая всё больше места, как паразит. Вы не поверите, что было дальше...

Мало того, что наши программисты постоянно терялись в коде программы и никогда не
могли найти то, что им нужно. Позднее выяснилось, что алгоритм, который мы
использовали, небезопасен: ЦРУ приложила руку к его разработке и специально
оставила в нём хитрую лазейку, которую долго никто не замечал. Чтобы данные пользователей
остались в сохранности, нам пришлось сменить алгоритм шифрования. А этот алгоритм в
программе повторялся 69 раз, и поэтому нам пришлось менять его 69 раз...

Конечно, что это не дело. Повторение одного и того же - это зло, особенно в программировании.
Надо было срочно чё-то с этим делать. Наши программисты вспомнили, что процессор умеет выполнять
инструкции не только последовательно: он умеет "прыгать". У процессоров семейства x86
есть регистр, который в языке ассемблера обозначается как `rip`, где "ip" означает
"instruction pointer", то есть "указатель на инструкцию". Число, записанное в нём -
это адрес следующей инструкции, которую процессору надо исполнить, его ещё
иногда называют *курсором*.
По умолчанию процессор сам увеличивает значение курсора таким образом, чтобы следующей
исполнялась инструкция, идущая непосредственно после текущей. Однако курсор
можно установить и вручную, заставив процессор выполнять инструкцию, находящуюся по
какому-то произвольному адресу.

На практике напрямую в регистр `rip` значения никогда не записывают. Для "прыжков"
предусмотрена специальная инструкция, которую обозначают как `jmp` (от слова "jump").
Но это всего лишь прикол процессоров семейства x86. Какой-то особо важной причины,
из-за которой `jmp` существует, нет.

Так вот: почему бы не реализовать сам алгоритм шифрования всего лишь один раз,
и, когда нам надо что-то зашифровать, просто "перепрыгивать" в часть программы,
где находится этот алгоритм? А когда он завершил свою работу - возвращаться назад.

<!-- TODO: иллюстрация, на которой изображён порядок выполнения инструкций со всеми прыжками -->

Есть одна проблема: алгоритм не знает, *откуда* в него перепрыгнули и куда надо возвращаться
по окончании выполнения. Исправить это довольно просто: перед тем, как перепрыгнуть в алгоритм,
надо сохранить в память адрес инструкции, следующей после инструкции "jmp", чтобы позже его
можно было достать из памяти и вернуться туда. Этот самый адрес называют **адресом возврата**. 

<!-- TODO: пример -->

Супер, проблема решена, больше нам не надо повторяться. Правда обидно, что мы снова изобрели велосипед.
Подобное решение проблемы повторяющегося кода настолько популярно, что вокруг
него сформировалась определённая терминология и даже специальные процессорные инструкции,
призванные облегчить программистам жизнь.
Их мы далее и разберём.

Сам алгоритм, то есть отдельную от основной программы последовательность инструкций, в которую можно перепрыгнуть,
а потом вернуться обратно, называют **функцией** или **процедурой**.

Когда ты перепрыгиваешь в функцию, говорят, что ты **вызываешь** её.

Данные, которые функция получает от того, кто её вызвал, называют **входными данными**
или **аргументами**. Они определяют работу самой функции. Например, у функции, шифрующей
что-то, может быть два аргумента: ключ шифрования и текст, который надо зашифровать.
Небольшие по объему данные передаются прямо в регистрах процессора. Если данных много, то
их оставляют в оперативной памяти, а через регистры передают лишь адрес и длину данных.

Данные, которые функция возвращает тому, кто её вызвал, называют **выходными данными**.
В примере с алгоритмом шифрования выходными данными является зашифрованный текст.

В процессорах семейства x86 есть специальные инструкции `call` и `ret` для вызова функций и возвращения
из них. `call` автоматически сохраняет в память адрес инструкции, следующей
сразу после неё, прежде чем прыгнуть. `ret` тоже делает сразу две вещи за раз: достаёт из памяти
этот адрес, а потом возвращается в него.

## Библиотеки и компоновщик
Функция - замечательное изобретение, позволяющее не повторять внутри программы одно и то же. Однако,
когда программ становится много, возникает <!-- TODO: какая такая же? --> абсолютно такая же проблема.
Поэтому необходимо придумать механизм,
который бы позволял сразу нескольким программам использовать одну и ту же функцию. Самый очевидный
способ достичь этого - дать возможность одной программе вызывать функции, находящиеся внутри
другой программы. **Библиотеки**, в общем и целом, так и работают, правда с кучей различных оговорок.

Библиотека - это как программа, только без самой программы. По сути, просто набор функций.
У обычных программ есть так называемая "точка входа" -
самая первая инструкция, с которой начинается выполнение. А у библиотеки точки входа нет. Следовательно,
инструкции внутри библиотеки не могут выполняться сами по себе. Выполняться они могут только тогда,
когда какая-то другая программа вызывает функцию из библиотеки.

Так же, как и программы, библиотеки хранятся в файлах на диске. В Windows эти файлы имеют
расширение `.dll`, в Linux и MacOS - `.so`. Библиотеки идентифицируют по именам
файлов, в которых хранятся. Имена библиотек, которые
нужны программе для выполнения, указываются в исполняемом файле. При запуске исполняемого файла
операционная система ищет эти библиотеки в файловой системе и автоматически копирует
их в память компьютера.

Опять встревает техническая проблема, требующая решения: ну запустил ты исполняемый файл, ну подгрузил
в оперативную память все нужные ему библиотеки. А дальше чё? Чтобы вызвать функцию, необходимо знать её точный
адрес, а адреса библиотечных функций меняются при каждом повторном запуске программы, потому что
сама библиотека каждый раз загружается в совершенно случайную область памяти. Постоянно загружать её
в одно и то же место просто невозможно, потому что это место может быть уже занято другой программой
или библиотекой.

Вывод: так как адреса функций мы заранее знать не можем, надо в самой программе вместо них оставлять какие-то
заглушки. Ну а, после того как все библиотеки были подгружены в память компьютера, заменять эти заглушки
настоящими адресами функций.

У каждой функции есть уникальное имя, нужное самим программистам, чтобы идентифицировать её и поверхностно
понимать, что она делает. Эти самые имена и используются как заглушки. А на настоящие адреса их заменяет
программа под названием **компоновщик**, которая является частью самой операционной системы.

## Статические библиотеки
Может быть такое, что библиотека, нужная программе, не будет присутствовать на компьютере пользователя.
В подобном случае может быть два исхода: либо пользователь установит библиотеку, либо удалит
программу. Скорее всего, произойдёт второе. Поэтому помимо **динамических библиотек**, то есть
библиотек, которые хранятся в файлах на компьютере пользователя и привязываются к программам непосредственно
перед началом их выполнения, также существуют **статические библиотеки**.

Статические библиотеки отличаются тем, что они включены прямо в исполняемый файл, содержащий саму программу.
Это даёт несколько преимуществ. Во-первых, библиотеку не нужно отдельно устанавливать.
Во-вторых, адреса всех функций известны заранее.

Однако есть и минусы. Так как библиотека намертво приварена к программе, её нельзя обновить отдельно
от программы. Это особенно плохо, когда в библиотеке обнаруживается критическая уязвимость.
Если все программы используют её как статическую библиотеку, то, чтобы исправить уязвимость,
необходимо будет обновить абсолютно каждую программу. А с динамическими библиотеками всё просто:
заменил файл, содержащий библиотеку, на новый, и готово.

Ещё один минус в том, что, при использовании статических библиотек, сами исполняемые файлы получаются
больше в размере. Хотя в современные дни эта проблема стоит не так уж и остро.

Объединение программы и статических библиотек в единый исполняемый файл происходит с помощью **статического
компоновщика**. Интеграцией динамических библиотек, соответственно, занимается **динамический компоновщик**,
хотя обычно и то, и то называют просто "компоновщик".
