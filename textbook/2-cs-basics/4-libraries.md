# Функции, библиотеки и компановщик

## ПППНП (Первое правило программирования: "не повторяйся")
<!-- TODO: Добавить мемасик в стиле XKCD про идиотизм всяких аббревиатур -->
Расскажу одну историю. Наши программисты писали <+>.
В разных местах программы необходимо было расшифровывать и зашифровывать данные.
Например, прежде чем сохранить данные на диск, надо было их зашифровать. Прежде
чем отправить их по сети - тоже. А алгоритмы шифрования ой какие сложные: они
занимают много инструкций, и если ты допустишь в алгоритме хоть одну ошибку, то он
станет бесполезным.

Но мы смирились. И во многих местах нашей программы повторялся один и тот же алгоритм
шифрования. Один и тот же набор инструкций, дублирующийся через всю нашу прогурамму
и потому занимающий всё больше места, как паразит. Вы не поверите, что было дальше...

Мало того, что наши программисты постоянно терялись в коде программы и никогда не
могли найти то, что им нужно. Позднее выяснилось, что алгоритм, который мы
использовали, небезопасен - ЦРУ приложила руку к его разработке и специально
оставила в нём хитрую лазейку, которую долго никто не замечал. Чтобы данные пользователей
остались в сохранности, нам пришлось сменить алгоритм шифрования. А этот алгоритм в
программе повторялся 20 раз, и поэтому нам пришлось менять его 20 раз...

<!-- TODO: fact-checking -->
Понятно, что это не дело. Повторение одного и того же - это зло, особенно в программировании.
Надо было чё-то с этим делать. Наши программисты вспомнили, что процессор умеет выполнять
инструкции не только последовательно: он умеет "прыгать". У процессоров семейства x86
есть регистр, который в языке ассемблера обозначается как "rip", где "ip" означает
"instruction pointer" ("указатель на инструкцию"). Число, записанное в этом
регистре - это адрес следующей инструкции, которую процессору надо выполнить.
В регистр rip можно записать любое произвольное значение и заставить процессор
выполнять инструкции по любому произвольному адресу.

Однако на практике напрямую в регистр rip значения никогда не записывают. Для "прыжков"
предусмотрена специальная инструкция, которую обозначают как "jmp" (от слова "jump").
Но это всего лишь прикол процессоров семейства x86, какой-то особо важной причины
существования этой инструкции нет.

Так вот: почему бы не реализовать сам алгоритм шифрования всего лишь один раз,
и, когда нам надо что-то зашифровать, просто "перепрыгивать" в часть программы,
где находится этот алгоритм? А когда он завершил свою работу - возвращаться назад.

<!-- TODO: иллюстрация, на которой изображён порядок выполнения инструкций со всеми прыжками -->

Есть одна проблема: алгоритм не знает, *откуда* в него перепрыгнули и куда надо возвращаться
по окончании выполнения. Исправить это довольно просто: перед тем, как перепрыгнуть в алгоритм,
надо сохранить в память адрес инструкции, следующей после инструкции "jmp". Этот
адрес называют "адрес возврата". Алгоритм потом сможет достать его из памяти
и заставить процессор вернуться туда. Проще простого.

<!-- TODO: пример -->

Супер, проблема решена, больше нам не надо повторяться. Подобное решение стало
настолько популярным, что вокруг него сформировалась определённая терминология и даже специальные
процессорные инструкции. Их мы далее и разберём.

Сам алгоритм, то есть отдельную от основной программы последовательность инструкций, в которую можно перепрыгнуть,
а потом оттуда вернуться, называют **функцией**.

Когда ты перепрыгиваешь в функцию, говорят, что ты **вызываешь** её.

Данные, которые функция получает от того, кто её вызвал, называют **входными данными**
или **аргументами**. Они определяют работу самой функции. Например, у функции, шифрующей
что-то, будет два аргумента: ключ шифрования и текст, который надо зашифровать.

Данные, которые функция возвращает тому, кто её вызвал, называют **выходными данными**.
В нашем примере к выходным данным будет относиться зашифрованный текст.

<!-- TODO: прочитать про эти инструкции, переписать абзац -->
Вместо того, чтобы писать `push rip; jmp <+>`, можно написать `call <+>`, это будет
эквивалентно. А вместо того, чтобы писать `pop rip` можно написать `ret`


## И снова добро пожаловать в Матрицу...
Операционная система - это виртуальный мир, поэтому мы скажем, что процессы - это люди,
живущие в нём. Они рождаются с какой-то конкретной целью и всю жизнь выполняют её.
После выполнения своей цели они умирают. Могут также быть "несчастные случаи",
когда происходит ошибка и процессу приходится экстренно прекращать работу. А ещё сам
пользователь компьютера может "убить" процесс. Это не просто игра слов, в Linux
и MacOS буквально есть команда под названием "kill", прекращающая работу процесса.









<!--
Допустим, у нас есть множество разных программ, каждой из которых надо обрабатывать картинки.
Браузер, файловый менеджер, программа для просмотра фотографий и так далее. Всем этим
программам нужен один и тот же функционал. Похоже, что надо бы добавить его в операционную
систему, чтобы не дублировать, но это плохая идея: по факту с картинками работает всего
лишь 5-10% программ, установленных на компьютере. Ни туда, ни сюда.

Так вот, библиотека - это набор функций, используемых сразу множеством программ. Библиотеки
не встроены в операционную систему и устанавливается отдельно, за исключением предустановленных.

Если ты пишешь программу, которая использует какую-либо библиотеку, 







Зачастую многие программы получаются довольно сложными. В них очень большое количество
инструкций и они занимают очень много места. Процесс, созданный из такой программы,
будет занимать ровно столько же или больше места, причём не на диске, а в оперативной
памяти. Если насоздавать кучу таких процессов, то очень скоро в виртуальном мире
просто закончится место. 
-->
