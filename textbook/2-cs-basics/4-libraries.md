# Функции, библиотеки и компоновщик

![Если программист использует кучу аббревиатур - бегите. Он призывает демона](/artwork/cs-101/demon.png)

## ПППНП (Первое правило программирования: "не повторяйся")

Расскажу одну историю. Наши программисты писали защищённый мессенджер.
В разных местах программы необходимо было расшифровывать и зашифровывать данные.
Например, прежде чем сохранить данные на диск, надо было их зашифровать. Прежде
чем отправить их по сети - тоже. А алгоритмы шифрования ой какие сложные: для их описания
нужно много инструкций, и если ты допустишь в алгоритме хоть одну ошибку, то он
станет, в лучшем случае, абсолютно бесполезным, а в худшем - опасным.

Но мы смирились. И во многих местах нашей программы повторялся один и тот же алгоритм
шифрования. Одна и та же последовательность инструкций, дублирующаяся через всю программу
и потому занимающая всё больше и больше места, как паразит. Вы не поверите, что было дальше...

Мало того, что наши программисты постоянно терялись в коде программы и никогда не
могли найти то, что им нужно. Позднее выяснилось, что алгоритм, который мы
использовали, небезопасен: ЦРУ приложила руку к его разработке и специально
оставила в нём хитрую лазейку, которую долго никто не замечал. Чтобы данные пользователей
остались в сохранности, нам пришлось сменить алгоритм шифрования. А этот алгоритм в
программе повторялся 69 раз, и поэтому нам пришлось менять его 69 раз...

Конечно, это не дело. Повторение одного и того же - это зло, особенно в программировании.
Нам надо было срочно чё-то с этим делать. Наши программисты вспомнили, что процессор умеет выполнять
инструкции не только последовательно: он умеет "прыгать". У процессоров семейства x86
есть регистр, который в языке ассемблера обозначается как `rip`, где "ip" означает
"instruction pointer", то есть "указатель на инструкцию". Число, записанное в нём -
это адрес следующей инструкции, которую процессору надо исполнить, его ещё
иногда называют *курсором*.

По умолчанию процессор сам увеличивает значение курсора таким образом, чтобы следующей
исполнялась инструкция, идущая непосредственно после текущей. Однако курсор
можно установить и вручную, заставив процессор выполнять инструкцию, находящуюся по
какому-то произвольному адресу. А потом, соответственно, все инструкции, идущие
после неё.

На практике напрямую в регистр `rip` значения никогда не записывают. Для "прыжков"
предусмотрена специальная инструкция, которую обозначают как `jmp` (от слова "jump").
Но это всего лишь прикол процессоров семейства x86. Какой-то особо важной причины,
из-за которой `jmp` существует, нет.

Так вот: почему бы не реализовать сам алгоритм шифрования всего лишь один раз,
и, когда нам надо что-то зашифровать, просто "перепрыгивать" в часть программы,
где находится этот алгоритм? А когда он завершил свою работу - возвращаться назад.

![Иллюстрация хода выполнения](/artwork/cs-101/function.png)

Есть одна проблема: алгоритм не знает, *откуда* в него перепрыгнули и куда надо возвращаться
по окончании выполнения. Исправить это довольно просто: перед тем, как перепрыгнуть в алгоритм,
надо сохранить в память адрес инструкции, следующей после инструкции `jmp`, чтобы позже его
можно было достать из памяти и вернуться туда. Этот самый адрес называют *адресом возврата*. 

![Иллюстрация хода выполнения с адресом возврата](/artwork/cs-101/function-2.png)

Супер, проблема решена, больше нам не надо повторяться. Правда обидно, что мы снова изобрели велосипед.
Подобное решение проблемы повторяющегося кода настолько популярно, что вокруг
него сформировалась определённая терминология и даже специальные процессорные инструкции,
призванные облегчить программистам жизнь.
Их мы далее и разберём.

Сам алгоритм, то есть отдельную от основной программы последовательность инструкций, в которую можно перепрыгнуть,
а потом вернуться обратно, называют *функцией* или *процедурой*.

Когда ты перепрыгиваешь в функцию, говорят, что ты *вызываешь* её.

Данные, которые функция получает от того, кто её вызвал, называют *входными данными*,
*параметрами* или *аргументами*. Они определяют работу самой функции. Например, у функции, шифрующей
что-то, может быть два аргумента: ключ шифрования и текст, который надо зашифровать.
Небольшие по объему данные передаются прямо в регистрах процессора. Если данных много, то
их оставляют в оперативной памяти, а через регистры передают лишь адрес и длину данных.

Данные, которые функция возвращает тому, кто её вызвал, называют *выходными данными*.
В примере с алгоритмом шифрования выходными данными является зашифрованный текст.

В процессорах семейства x86 есть специальные инструкции `call` и `ret` для вызова функций и возвращения
из них. `call` автоматически сохраняет в память адрес инструкции, следующей
сразу после неё, прежде чем прыгнуть. `ret` тоже делает сразу две вещи за раз: достаёт из памяти
этот адрес, а потом возвращается в него.

## Библиотеки и компоновщик
Функция - замечательное изобретение, позволяющее не повторять внутри программы одно и то же. Однако,
когда программ становится много, возникает ровно такая же самая проблема.
Поэтому необходимо придумать механизм,
который бы позволял сразу нескольким программам использовать одну и ту же функцию. Самый очевидный
способ достичь этого - дать возможность одной программе вызывать функции, находящиеся внутри
другой программы. **Библиотеки**, в общем и целом, так и работают, правда с огромным количеством различных оговорок.

Библиотека - это как программа, только без самой программы. По сути, просто набор функций.
У обычных программ есть так называемая "точка входа" -
самая первая инструкция, с которой начинается выполнение. А у библиотеки точки входа нет. Поэтому
инструкции внутри библиотеки не могут выполняться сами по себе. Выполняться они могут только тогда,
когда какая-то другая программа вызывает функцию из библиотеки.

Так же, как и программы, библиотеки хранятся в файлах на диске. В Windows эти файлы имеют
расширение `.dll`, в Linux и MacOS - `.so`. Имена библиотек, которые нужны
программе для выполнения, указываются внутри исполняемого файла. При его запуске
операционная система сама ищет все нужные библиотеки и копирует
их с диска в память компьютера.

Опять встревает техническая проблема, требующая решения: ну запустил ты исполняемый файл, ну нашел и подгрузил
все нужные ему библиотеки. А дальше чё? Чтобы вызвать функцию, необходимо знать её точный
адрес, а адреса библиотечных функций меняются при каждом повторном запуске программы, ведь
сама библиотека каждый раз загружается в совершенно случайную область памяти. Постоянно загружать её
в одно и то же место просто невозможно, потому что это место может быть занято другой программой
или библиотекой.

Вывод: так как адреса функций мы заранее знать не можем, в самой программе надо вместо них оставлять какие-то
заглушки. Ну а, после того как все библиотеки были подгружены в память компьютера, заменять эти заглушки
настоящими адресами функций.

У каждой функции есть уникальное имя, нужное самим программистам, чтобы идентифицировать её и поверхностно
понимать, что она делает. Эти самые имена и используются как заглушки. А на настоящие адреса их заменяет
программа под названием *динамический компоновщик*, которая является частью самой операционной системы.
Прежде чем начать выполняться, абсолютно каждая программа должна быть обработана компоновщиком.

Важное замечание: компоновщик не меняет саму программу на 

## Статические библиотеки
Может быть такое, что библиотека, нужная программе, не будет присутствовать на компьютере пользователя.
В подобном случае может быть два исхода: либо пользователь установит библиотеку, либо удалит
программу. Скорее всего, произойдёт второе. Поэтому помимо **динамических библиотек**, то есть
библиотек, которые хранятся в файлах на компьютере пользователя и привязываются к программам непосредственно
перед началом их выполнения, также существуют **статические библиотеки**.

Статические библиотеки отличаются тем, что они включены прямо в исполняемый файл, содержащий саму программу.
Это даёт несколько преимуществ. Во-первых, библиотеку не нужно отдельно устанавливать.
Во-вторых, адреса всех функций известны заранее.

Однако есть и минусы. Так как библиотека намертво приварена к программе, её нельзя обновить отдельно
от программы. Это особенно плохо, когда в библиотеке обнаруживается критическая уязвимость.
Если все программы используют её как статическую библиотеку, то, чтобы исправить уязвимость,
необходимо будет обновить абсолютно каждую программу. А с динамическими библиотеками всё просто:
заменил файл, содержащий библиотеку, на новый, и готово.

Ещё один минус в том, что, при использовании статических библиотек, сами исполняемые файлы получаются
больше в размере. Хотя в современные дни эта проблема стоит не так уж и остро.

Объединение программы и статических библиотек в единый исполняемый файл происходит с помощью *статического
компоновщика*. Интеграцией динамических библиотек, соответственно, занимается *динамический компоновщик*,
хотя обычно и то и то просто называют *компоновщиком*.
