# Высокоуровневые языки программирования

<!-- TODO: Иллюстрация: Покупайте лень. Продам за бесценок -->

## Зачем они нужны?
Язык ассемблера - хорошая вещь. По крайне мере, если тебе надо написать что-нибудь не слишком сложное.
Однако, когда в программе много инструкций, запутаться в них проще простого.
Да и с памятью приходится работать вручную. А ещё необходимо учитывать особенности процессора и ОС,
под которые ты пишешь программу. Создавать реально сложные программы на языке
ассемблера можно, но это боль. На потакание процессору и операционной системе уходит
больше сил и времени, чем на написание логики самой программы. 

Мы уже абстрагировались от процессорных инструкций с помощью языка ассемблера. И от языка
ассемблера тоже абстрагируемся. Лучше один раз напрячься и создать инструмент, который
облегчит тебе работу в будущем, чем страдать, делая всё вручную.
То же самое можно сказать при помщи выражения "Лень - двигатель прогресса".

Программисты - люди ленивые, поэтому давным давно они хорошенько напряглись и создали высокоуровнеые
языки программирования. Их суть вот в чём: ты описываешь свою программу при помощи особого
"высокоуровневого" языка, представляющего из себя смесь человеческого и математического языков.
После этого специальная программа под названием "компилятор" переводит эту запись на язык
ассемблера, либо напрямую в процессорные инструкции.

<!-- 
TODO: Привести аналогию, чтобы описать различия между высокоуровнемыми языками и ассемблером.
Рассказать о том, компиляция - это необратимый процесс.
-->

Ещё один плюс высокоуровневых языков в том, что программы, написанные не них, как правило,
полностью отвязаны от конкретного процессора или операционной системы. Программисту достаточно
написать программу один раз, а адаптировать её под различные платформы будет сам компилятор. <!-- если есть подходящий переводчик-->

## Основы (Почти) любого языка программирования
Давайте не пытаться изучать язык(синтаксиc) ассемблера с нуля, а поймём, что же он делает на основных примерах.
Потому что именно ради умения прочитать ассемблер, его и изучают в современных условиях.
### Переменные и типы данных
<!-- TODO -->
Вводим переменные:
```
C++

#include <iostream> // Подключаем библиотеку для ввода/вывода

int main() {
    // Объявляем и инициализируем переменные
    int num1 = 5; // Первая переменная
    int num2 = 10; // Вторая переменная
    int result;    // Переменная для хранения результата

    // Сложение
    result = num1 + num2; // Складываем num1 и num2, записываем в result

    // Вывод результата
    std::cout << "Результат: " << result << std::endl; // Выводим результат на экран

    return 0; // Завершаем программу
}
```
Assembler(TASM)
```
.MODEL SMALL                  ; Указывает на использование малой модели памяти. В этой модели сегменты кода и данных помещаются в пределах 64 КБ.
.STACK 100h                   ; Определяет размер стека(здесь храняться временные данные), равный 256 байтам (100h в шестнадцатеричном).
.DATA                         ; Начало секции данных, где объявляются переменные.
    num1 DB 5                 ; Define Byte Объявляет переменную num1 типа Byte (1 байт) и инициализирует её значением 5.
    num2 DB 10                ; Define Byte Объявляет переменную num2 типа Byte (1 байт) и инициализирует её значением 10.
    result DB ?               ; Define Byte Объявляет переменную result типа Byte (1 байт) без инициализации (будет хранить результат).
    message DB 'Результат: $' ; Объявляет строку, которую будем выводить. Символ $ указывает на конец строки.

.CODE                         ; Начало секции кода, где располагается исполняемая часть программы.
MAIN PROC                     ; Объявляет начало процедуры MAIN.
    MOV AX, @DATA             ; Загружает адрес сегмента данных в регистр AX.
    MOV DS, AX                ; Перемещает значение из AX в регистр DS, тем самым инициализируя сегмент данных.
    ; Сложение
    MOV AL, num1              ; Загружает(перемещает) значение переменной num1 в регистр AL(это младший байт общего регистра AX).
    ADD AL, num2              ; Добавляет значение переменной num2 к содержимому регистра AL. Теперь AL содержит 15.
    MOV result, AL            ; Сохраняет(перемещает) значение, находящееся в AL (15), в переменной result.

    ; Выводим сообщение
    MOV DX, OFFSET message    ; OFFSET возвращает адрес переменной message. MOV Загружает адрес строки message в регистр DX.
    MOV AH, 09h               ; Функция прерывания 09h, которая указывает на то, что мы собираемся вывести строку на экран.
    INT 21h                   ; Вызов прерывания DOSа, которое выполняет вывод строки в DX на экран.

    ; Выводим результат
    MOV AL, result            ; Загружает значение result в AL
    ADD AL, 30h               ; Преобразуем число в ASCII-код (например, 0 -> '0')
    MOV DL, AL                ; Перемещаем в DL для вывода
    MOV AH, 02h               ; Функция 02h для вывода символа
    INT 21h                   ; Вызов прерывания DOSа, которое выполняет вывод строки в DX на экран.

    ; Завершение программы
    MOV AX, 4C00h             ; Подготавливает завершение программы. Код 4C в AX используется для завершения подпрограммы.
    INT 21h                   ; Вызывает прерывание 21h, чтобы DOS завершил выполнение программы.
MAIN ENDP                     ; Объявляет конец процедуры MAIN.
END MAIN                      ; Указывает, что программа заканчивается.
```

### Условия и циклы
<!-- TODO -->

### Функции и процедуры
<!-- TODO -->

### Объекты и ООП
<!-- TODO -->

### Библиотеки и юниты
<!-- TODO -->

<!--
Это старая версия. Интерпретаторы упоминать вообще не нужно. 

## Что и зачем?
Программировать на ассемблере реально, но очень сложно и трудоёмко. Программисты - люди ленивые, им
вообще не хочется иметь дело с Бобом. Хочется общаться с компьютером на человеческом языке.
Для удовлетворения этой самой хотелки и были созданы высокоуровневые языки программирования.
По факту большинство языков скорее заимствуют всё из языка математики, а не из человеческого языка,
однако даже математический язык намного более понятен человеку, чем язык ассемблера.

Ещё один плюс высокоуровневых языков в том, что код, написанный на них, как правило, не привязан
к конкретной процессорной архитектуре или операционной системе. А это значит, что программу
достаточно написать всего лишь один раз, а её адаптацией под различные платформы будет
заниматься компилятор.

Команды, написанные на каком-то языке программирования, ещё надо перевести на понятный
процессору язык. Есть много разных способов сделать это. Каждый инструмент, выполняющий
подобную задачу, по-своему уникален, однако для простоты их делят на две категории:
1. Компиляторы. Они берут написанный человеком текст, *целиком* преобразовывают его в
набор инструкций для процессора и сохраняют их в файл для дальнейшего использования.
2. Интерпретаторы. Они преобразовывают написанный человеком код в инструкции по маленьким частям.
Чаще всего - по одной строчке. И, чаще всего, не сохраняют эти инструкции в файл, а сразу же
отправляют их процессору на исполнение.

Некоторые компиляторы преобразовывают код в инструкции для процессора напрямую. Некоторые
генерируют мнемоническую запись этих самых инструкций на языке ассемблера, а потом
отправляют ассемблеру, чтобы тот преобразовал их в инструкции. Это целиком и
полностью зависит от внутреннего устройства компилятора.

Компилятор, сам по себе, не выдаёт готовый исполняемый файл. Он производит так называемый
"объектный файл" - инструкции для процессора, в которых ещё не разрешены ссылки
на библиотечные функции. Чтобы разрешить их, объектный файл (Или сразу несколько
зависящих друг от друга объектных файлов) надо пропустить через компановщик.
Компановщик соберёт все эти файлы в единый исполняемый файл, а также разрешит
ссылки на �
