<!-- TODO: файловые системы -->

# Операционные системы и компиляторы

## \_Вещи, про которые надо рассказать
0. Окунулись в прошлое
1. Зачем нужны операционки, их история, какие вообще есть и чем отличаются
2. Немного расскаазть про внутреннее устройство: чё оски умеют делать,
    как с ними общаться
3. Компиляторы, ассемблеры и дизассемблеры, статические и динамические библиотеки

## Зачем операционки вообще нужны
Бывают случаи, когда нужно выполнять сразу несколько программ параллельно. А Боб у
нас только один (Мы сейчас не учитываем существование многоядерных процессоров).
Следовательно, нужна какая-то программа, которая бы контролировала выполнение всех
других программ и заставляла Боба периодически переключаться с выполнения одной
программы на выполнение другой. Операционная система - это и есть такая
программа, только с ещё целой кучей дополнительного функционала. На практике оказывается,
что почти любой программе нужны одни и те же вещи: возможность работать с файлами,
общаться с другими программами, взаимодействовать с сетью и так далее. Намного
проще реализовать этот функционал один раз внутри операционной системы и дать
программам к нему доступ, чем реализовывать его внутри каждой отдельной программы.

Внутри любой операционной системы программы хранятся в виде файлов в файловой
системе. Такие файлы, хранящие внутри себя программу, называются "исполняемыми".
Каждый исполняемый файл, помимо самих инструкций для процессора, включает
различную мета-информацию, нужную ОС. В разных операционках сам формат и структура
исполняемых файлов может сильно отличаться. Для справки: в Windows используется
формат "EXE", а в Linux - "ELF64".

Переключение между выполнением разных программ может происходить по-разному.
В старых версиях DOS каждая программа должна была добровольно передавать контроль
операционной системе, чтобы та выбрала следующую программу на выполнение.
На практике это работало плохо, потому что некоторым разработчикам было пофиг.
Они писали программы, которые либо передавали контроль операционке очень редко,
либо не передавали вообще, забирая себе все ресурсы компьютера.
Поэтому в современных операционных системах контроль у программы отбирается
насильно. У Боба в голове есть таймер, с помощью которого он сам контролирует
время, в течение которого программа может выполняться непрерывно. А когда
время истекает - он сохраняет в оперативную память все числа, связанные с выполнением
программы, которые он держал в своей голове (Регистры, короче говоря), и передаёт контроль
операционке - по сути, "перепрыгивает" на инструкции, которые выбирают следующую программу
на выполнение.

Часть ядра операционной системы, контролирующая выполнение программ, называется "scheduler"
("Шедулер"). Помимо шедулера ядро может включать в себя ещё целый ряд компонентов. К примеру,
ядро Linux включает в себя файловые системы, инструменты для виртуализации, а также
драйвера к практически всему железу, которое вообще существует на Земле. И это ещё далеко не всё.

Полноценная операционная система состоит из этого самого ядра и набора предустановленных программ,
позволяющих человеку работать с компьютером. К ним относятся, к примеру,
текстовый редактор, компилятор, а также всякие сторонние утилиты узкого назначения. Современные
операционные системы, как правило, направлены на обычных людей, а не на программистов,
поэтому в них включают графический интерфейс, набор офисных программ и браузер, но при
этом в них из коробки отсутствуют компиляторы или хотя бы приличный текстовый редактор
(В первую очередь это относится к Windows)

## Ассемблер
Как тут уже говорилось, процессорные инструкции для обычного человека выглядят всего лишь
как наборы бессмысленных чисел. Во времена, когда компьютеры только зарождались и у процессоров
было совсем немного инструкций, их, наверное, было бы реально выучить и писать от руки.
Однако сейчас в любой современный процессор закладывают сотни самых различных инструкций.
Даже очень умный человек не сможет в таком разобраться. Для решения этой самой проблемы
существует "ассемблер". Этот термин обозначает две вещи:
1. Мнемоническая запись процессорных инструкций, более-менее понятная хорошо обученному
человеку
2. Программа, которая эту самую мнемоническую запись преобразовывает в настоящие инструкции
для процессора

К примеру, возьмём вот такую последовательность инструкций для процессора архитектуры x86:
```
184 57 5 0 0 80
```

Нихрена не понятно. А вот в мнемонической записи это будет выглядеть таким образом:

```asm
mov rax,1337
push rax
```

Переводя на человеческий язык: "Помести в регистр rax число 1337, а потом запиши его в память компьютера"

С помощью ассемблера мнемоническую запись, понятную человеку, можно преобразовать в последовательность
инструкций (Бессмысленных чисел), понятную процессору. В обратную сторону эту операцию тоже можно
провернуть. Программа, делающая такую штуку, называется "дизассемблер".

## Библиотеки


## Высокоуровневые языки программирования
Программировать на ассемблере реально, но очень сложно и трудоёмко. Программисты - люди ленивые, им
вообще не хочется иметь дело с Бобом. Хочется общаться с компьютером на человеческом языке.
Для удовлетворения этой самой хотелки и были созданы высокоуровневые языки программирования.
По факту большинство языков скорее заимствуют всё из языка математики, а не из человеческого языка,
однако даже математический язык намного более понятен человеку, чем язык ассемблера.

Команды, написанные на каком-то языке программирования, ещё надо перевести на понятный
процессору язык. Есть много разных способов сделать это. Каждый инструмент, выполняющий
подобную задачу, по-своему уникален, однако для простоты их делят на две категории:
1. Компиляторы. Они берут написанный человеком текст, *целиком* преобразовывают его в
набор инструкций для процессора и сохраняют их в файл для дальнейшего использования.
2. Интерпретаторы. Они преобразовывают написанный человеком код в инструкции по маленьким частям.
Чаще всего - по одной строчке. И, чаще всего, не сохраняют эти инструкции в файл, а сразу же
отправляют их процессору на исполнение.

Компилятор, сам по себе, не выдаёт готовый исполняемый файл. Он производит так называемый
"объектный файл" - инструкции для процессора, которые не привязаны к операционной системе
и поэтому не готовы к тому, чтобы их исполнить. Объектный файл надо пропустить через
утилиту под названием компоновщик, которай cгенерирует из него полноценный
исполняемый файл.
